{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{375:function(t,a,e){\"use strict\";e.r(a);var _=e(45),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"http状态码\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http状态码\"}},[t._v(\"#\")]),t._v(\" HTTP状态码\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_1xx\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1xx\"}},[t._v(\"#\")]),t._v(\" 1XX\")]),t._v(\" \"),e(\"p\",[t._v(\"100 Continue：继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息。\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_2xx\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2xx\"}},[t._v(\"#\")]),t._v(\" 2XX\")]),t._v(\" \"),e(\"p\",[t._v(\"200 OK：正常返回信息。例：对于GET，表示成功请求资源并返回。\")]),t._v(\" \"),e(\"p\",[t._v(\"201 Created：请求成功并且服务器创建了新的资源。\")]),t._v(\" \"),e(\"p\",[t._v(\"202 Accepted：服务器已接收请求，但尚未处理。\")]),t._v(\" \"),e(\"p\",[t._v('204 No Content：请求已经执行成功，但没有内容。若服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码。服务器也可以对GET请求返回此响应代码，这表明“客户端请求的资源存在，但其表示是空的”。注意与304(\"Not Modified\")的区别。204常常用在Ajax应用里。服务器通过这个响应代码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素。')]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_3xx\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3xx\"}},[t._v(\"#\")]),t._v(\" 3XX\")]),t._v(\" \"),e(\"p\",[t._v(\"301 Moved Permanently：请求的资源已经永久变了地址，永久重定向\")]),t._v(\" \"),e(\"p\",[t._v('302 Found： 请求的资源暂时变了地址，临时重定向。这个响应代码是造成大多数重定向方面的混乱的最根本原因。它应该是像307那样被处理。实际上，在HTTP 1.0中，响应代码302的名称是”Moved Temporarily”，不幸的是，在实际生活中，绝大多数客户端拿它像303一样处理。它的不同之处在于当服务器为客户端的PUT，POST或者DELETE请求返回302响应代码时，客户端要怎么做。为了消除这一混淆，在HTTP 1.1中，该响应代码被重命名为\"Found\"，并新加了一个响应代码307。这个响应代码目前仍在广泛使用，但它的含义市混淆的，所以我建议你的服务发送307或者303，而不要发送302.除非你知道正在与一个不能理解303或307的HTTP 1.0客户端交互。')]),t._v(\" \"),e(\"p\",[t._v(\"303 See Other：临时性重定向，且总是使用 \"),e(\"code\",[t._v(\"GET\")]),t._v(\" 请求新的 \"),e(\"code\",[t._v(\"URI\")]),t._v(\"。返回一个响应文档的URI。\")]),t._v(\" \"),e(\"p\",[t._v(\"304 Not Modified：自从上次请求后，请求的网页未修改过。请求的资源命中协商缓存，即Etag未改变（服务端此资源的Etag==请求头里的If-Match里的Etag，即第一次拿到这个资源时拿到的Etag）或是资源最后更新时间未改变（服务端此资源最后更新时间==请求中的If-modified-since，即第一次拿到这个资源时拿到的Last-modified），这2个的优先级Etag高，因为资源更新时间以秒为单位，不如Etag精确反应文件改变\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_4xx\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4xx\"}},[t._v(\"#\")]),t._v(\" 4XX\")]),t._v(\" \"),e(\"p\",[t._v(\"400 Bad Request：服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\")]),t._v(\" \"),e(\"p\",[t._v(\"401 Unauthorized：请求未授权。客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书。客户端提供了错误的证书，或者根本没有提供证书。这里的证书（credential）可以是一个用户名/密码，也可以市一个API key，或者一个认证令牌。客户端常常通过向一个URI发送请求，并查看收到401响应，以获知应该发送哪种证书，以及证书的格式。如果服务器不想让未授权的用户获知某个资源的存在，那么它可以谎报一个404而不是401。这样做的缺点是：客户端需要事先知道服务器接受哪种认证--这将导致HTTP摘要认证无法工作。\")]),t._v(\" \"),e(\"p\",[t._v(\"403 Forbidden: 禁止访问。客户端请求的结构正确，但是服务器不想处理它。这跟证书不正确的情况不同--若证书不正确，应该发送响应代码401。该响应代码常用于一个资源只允许在特定时间段内访问，\")]),t._v(\" \"),e(\"p\",[t._v(\"或者允许特定IP地址的用户访问的情况。403暗示了所请求的资源确实存在。跟401一样，若服务器不想透露此信息，它可以谎报一个404。\")]),t._v(\" \"),e(\"p\",[t._v(\"404 Not Found：找不到与URI相匹配的资源\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_5xx\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5xx\"}},[t._v(\"#\")]),t._v(\" 5XX\")]),t._v(\" \"),e(\"p\",[t._v(\"500 Internal Server Error：最常见的服务器端错误。对于大多数web框架，如果在执行请求处理代码时遇到了异常，它们就发送此响应代码。\")]),t._v(\" \"),e(\"p\",[t._v(\"503 Service Unavailable：服务器端暂时无法处理请求（可能是过载或维护）。\")])])}),[],!1,null,null,null);a.default=v.exports}}]);","extractedComments":[]}